<div id="april-fools" style="display:block; padding-right: 15px;
padding-left: 15px;
margin-right: auto;
margin-left: auto;">
  <canvas id="board"></canvas>
</div>

<script type="application/javascript">
  function toggleAprilFools() {
    var div1 = document.getElementById('matrix-enterprise');
    var div2 = document.getElementById('april-fools');
    var btn = document.getElementById('game-toggle');
    if (div1.style.display === 'none') {
      div1.style.display = 'block';
      div2.style.display = 'none';
      btn.innerHTML = 'Back to Game'
    } else {
      div1.style.display = 'none';
      div2.style.display = 'block';
      btn.innerHTML = 'Back to Normal'
    }
  }
  </script>

<script type="application/javascript">
  const AGAME_DEFAULT_GAME_MODE = "Medium";

  const AGAME_BOARD_WIDTH = 1500;
  const AGAME_BOARD_HEIGHT = 900;
  const AGAME_BOARD_MAX_ROWS = 15;
  
  // const APADDLE_WIDTH = 700; //1000 for testing, 100 normal
  const AGAME_PADDLE_WIDTH = 200; //1000 for testing, 100 normal
  const AGAME_PADDLE_HEIGHT = 20;
  const AGAME_PADDLE_VELOCITY_X = 20;
  
  const AGAME_BALL_WIDTH = 10;
  const AGAME_BALL_HEIGHT = 10;
  const AGAME_BALL_VELOCITY_X = 25; //15 for testing, 3 normal
  const AGAME_BALL_VELOCITY_Y = 10; //10 for testing, 2 normal
  
  const AGAME_BLOCK_X_OFFSET = 10;
  const AGAME_BLOCK_Y_OFFSET = 45;
  const AGAME_MIN_BLOCK_HEIGHT = 35;
  
  const AGAME_SCORE_INCREMENT = 100;
  const AGAME_SCORE_BONUS = 10000;
  
  const AGAME_MIN_FONT_SIZE = 6;
  const AGAME_MAX_FONT_SIZE = 20;
  
  class Board {
    constructor(width, height) {
      this.padding = 20;
      this.width = width;
      this.height = height;
      this.context = null;
    }
  
    setupBoard() {
      let board = document.getElementById("board");
      board.style.left = this.padding + "px";
      board.style.top = this.padding + "px";
      board.style.backgroundColor = game.theme.currentPreset.backgroundColor;
      board.height = this.height;
      board.width = this.width;
      this.context = board.getContext("2d");
      this.resizeBoard();
    }
  
    resizeBoard() {
      this.width = window.innerWidth - 2 * this.padding;
      this.height = window.innerHeight - 2 * this.padding;
      let board = document.getElementById("board");
      board.height = this.height;
      board.width = this.width;
    }
  }
  
  class Paddle {
    constructor(width, height, velocityX) {
      this.width = width;
      this.height = height;
      this.velocityX = velocityX;
      this.x = null;
      this.y = null;
    }
  
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
  
    generatePaddleData(boardWidth, boardHeight) {
      this.x = boardWidth / 2 - this.width / 2;
      this.y = boardHeight - this.height - 5;
    }
  }
  
  class Ball {
    constructor(width, height, velocityX, velocityY) {
      this.width = width;
      this.height = height;
      this.velocityX = velocityX;
      this.velocityY = velocityY;
      this.x = null;
      this.y = null;
    }
  
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
  
    generateInitialBall(boardWidth, boardHeight) {
      this.x = boardWidth * 0.5;
      this.y = boardHeight * 0.7;
      this.velocityX = Math.random() < 0.5 ? -this.velocityX : this.velocityX;
    }
  }
  
  class Block {
    constructor(width, height, x, y, wordsArray, fontSize) {
      this.width = width;
      this.height = height;
      this.x = x;
      this.y = y;
      this.wordsArray = wordsArray;
      this.fontSize = fontSize;
      this.break = false;
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
  }
  
  class GameState {
    constructor() {
      this.gameHistory = [];
      this.initialState();
    }
    initialState() {
      this.score = 0;
      this.lives = 3;
      this.gameOver = false;
      this.gamePaused = true;
      this.gameStarted = false;
      this.blockCount = 0;
      this.keyState = {};
      this.minBallVelocityX = AGAME_BALL_VELOCITY_X * -1;
      this.maxBallVelocityX = AGAME_BALL_VELOCITY_X;
      this.difficulty = AGAME_DEFAULT_GAME_MODE;
    }
  }
  
  class Level {
    constructor() {
      this.currentLevel = 1;
    }
    nextLevel() {
      this.currentLevel++;
      game.state.score += AGAME_SCORE_BONUS;
      game.attackMatrix = createAttackMatrix();
      game.createBlocks();
      game.theme.changeTheme(this.currentLevel);
    }
    displayLevel() {
      game.board.context.fillStyle = game.theme.textColor;
      game.board.context.font = "20px sans-serif";
      game.board.context.fillText("Level: " + this.currentLevel, game.board.width - 200, 25);
    }
  }
  
  class Theme {
    constructor() {
      this.presets = [
        {
          title: "Default",
          borderColor: "red",
          backgroundColor: "#303030",
          textColor: "white",
          blockColor: "white",
          blockTextColor: "black",
          // paddleColor: "lightgreen",
          paddleColor: "red",
          ballColor: "white",
          pauseMessageBoxColor: "red",
          pauseMessageTextColor: "white",
          gameOverMessageBoxColor: "red",
          gameOverMessageTextColor: "white",
        },
      ];
      this.currentPreset = this.presets[0];
    }
    changeTheme(level) {
      this.currentPreset = this.presets[(level - 1) % this.presets.length];
      console.log("Changed theme to: " + this.currentPreset.title);
    }
    applyTheme() {
      game.board.context.canvas.style.borderColor = this.currentPreset.borderColor;
      game.board.context.canvas.style.backgroundColor = this.currentPreset.backgroundColor;
      game.paddle.color = this.currentPreset.paddleColor;
      game.ball.color = this.currentPreset.ballColor;
      game.blocks.forEach((block) => {
        block.color = this.currentPreset.blockColor;
        block.textColor = this.currentPreset.blockTextColor;
      });
    }
  }
  
  class Particle {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.size = Math.random() * 5 + 1;
      this.speedX = Math.random() * 3 - 1.5;
      this.speedY = Math.random() * 3 - 1.5;
    }
    update() {
      this.x += this.speedX;
      this.y += this.speedY;
      if (this.size > 0.1) this.size -= 0.1;
    }
    draw() {
      game.board.context.fillStyle = 'orange';
      game.board.context.strokeStyle = 'red';
      game.board.context.lineWidth = 2;
      game.board.context.beginPath();
      game.board.context.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      game.board.context.closePath();
      game.board.context.fill();
      game.board.context.stroke();
    }
  }
  class ParticleSystem {
    constructor() {
      this.particles = [];
    }
    createExplosion(x, y, count) {
      for(let i = 0; i < count; i++) {
        this.particles.push(new Particle(x, y));
      }
    }
    updateParticles() {
      for(let i = 0; i < this.particles.length; i++) {
        this.particles[i].update();
        if(this.particles[i].size <= 0.1) {
          this.particles.splice(i, 1);
          i--;
        }
      }
    }
    drawParticles() {
      for(let i = 0; i < this.particles.length; i++) {
        this.particles[i].draw();
      }
    }
  }
  
  class Game {
    constructor() {
      this.board = new Board(AGAME_BOARD_WIDTH, AGAME_BOARD_HEIGHT);
      this.paddle = new Paddle(AGAME_PADDLE_WIDTH, AGAME_PADDLE_HEIGHT, AGAME_PADDLE_VELOCITY_X);
      this.ball = new Ball(AGAME_BALL_WIDTH, AGAME_BALL_HEIGHT, AGAME_BALL_VELOCITY_X, AGAME_BALL_VELOCITY_Y);
      this.level = new Level();
      this.theme = new Theme();
      this.state = new GameState();
      this.animationId = null;
      this.blocks = [];
      this.attackMatrix = null;
      this.particleSystem = new ParticleSystem();
    }
  
    // Setup methods
    setup = () => {
      try {
        this.setupCanvas();
        this.setupGame();
        this.setupEventListeners();
      } catch (error) {
        console.error("Error during setup: ", error);
      }
    };
  
    setupCanvas = () => {
      try {
        this.board.setupBoard();
        this.paddle.generatePaddleData(this.board.width, this.board.height);
        this.ball.generateInitialBall(this.board.width, this.board.height);
        this.state.gamePaused = true;
        this.displayStartScreen();
      } catch (error) {
        console.error("Error setting up the canvas: ", error);
      }
    };
  
    setupGame = () => {
      try {
        this.theme.applyTheme();
        this.attackMatrix = createAttackMatrix();
        this.blockRows = this.attackMatrix.length;
        this.blockColumns = this.attackMatrix[0].length;
        this.createBlocks();
      } catch (error) {
        console.error("Error setting up the game: ", error);
      }
    };
  
    setupEventListeners = () => {
      try {
        window.addEventListener("resize", this.handleResize);
  
        document.addEventListener("keydown", (e) => {
          this.state.keyState[e.code] = true;
          if (e.code === "ArrowLeft") {
            this.handleArrowLeftKey();
          } else if (e.code === "ArrowRight") {
            this.handleArrowRightKey();
          } else if (e.code === "Space") {
            this.handleSpaceKey();
          }
        });
  
        document.addEventListener("keyup", (e) => {
          this.state.keyState[e.code] = false;
        });
  
        this.board.context.canvas.addEventListener("mousemove", (e) => {
          if (!this.state.gamePaused) {
            const rect = this.board.context.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            let newPaddleX = x - this.paddle.width / 2;
            if (newPaddleX < 0) {
              newPaddleX = 0;
            } else if (newPaddleX > this.board.width - this.paddle.width) {
              newPaddleX = this.board.width - this.paddle.width;
            }
            this.paddle.x = newPaddleX;
          }
        });
  
        this.board.context.canvas.addEventListener("click", (e) => {
          if (!this.state.gameStarted) {
            const rect = this.board.context.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            this.buttons.forEach((button) => {
              if (x > button.x && x < button.x + button.width && y > button.y && y < button.y + button.height) {
                this.ball.velocityX = button.velocity;
                this.ball.velocityY = button.velocity;
                this.state.minBallVelocityX = -button.velocity;
                this.state.maxBallVelocityX = button.velocity;
                this.state.difficulty = button.text;
                this.startGame();
              }
            });
          }
        });
      } catch (error) {
        console.error("Error setting up event listeners: ", error);
      }
    };
  
    drawDifficultyButtons = () => {
      const buttonWidth = 100;
      const buttonHeight = 50;
      const buttonY = this.board.height - 100; // Position the buttons at the bottom of the canvas
      const buttonSpacing = 20;
      this.buttons = [
        {
          text: "Easy",
          x: this.board.width / 2 - buttonWidth * 1.5 - buttonSpacing,
          y: buttonY,
          width: buttonWidth,
          height: buttonHeight,
          velocity: 4.5,
        },
        {
          text: "Medium",
          x: this.board.width / 2 - buttonWidth / 2,
          y: buttonY,
          width: buttonWidth,
          height: buttonHeight,
          velocity: 7.5,
        },
        {
          text: "Hard",
          x: this.board.width / 2 + buttonWidth / 2 + buttonSpacing,
          y: buttonY,
          width: buttonWidth,
          height: buttonHeight,
          velocity: 10.5,
        },
      ];
      this.buttons.forEach((button) => {
        this.board.context.fillStyle = "lightgray";
        this.board.context.fillRect(button.x, button.y, button.width, button.height);
        this.board.context.fillStyle = "black";
        this.board.context.font = "20px sans-serif";
        this.board.context.textAlign = "center";
        this.board.context.textBaseline = "middle";
        this.board.context.fillText(button.text, button.x + button.width / 2, button.y + button.height / 2);
      });
      this.board.context.textAlign = "start";
      this.board.context.textBaseline = "alphabetic";
    };
  
    // Game loop methods
    gameLoop = () => {
      this.update();
      this.draw();
      if (!this.state.gameOver) {
        this.animationId = requestAnimationFrame(this.gameLoop);
      }
    };
  
    update = () => {
      if (!this.state.gamePaused) {
        if (this.state.keyState["ArrowLeft"]) {
          this.handleArrowLeftKey();
        }
        if (this.state.keyState["ArrowRight"]) {
          this.handleArrowRightKey();
        }
        this.handleBallCollision();
        this.checkBallBounds();
        this.checkNextLevel();
        // Update ball's position
        this.ball.x += this.ball.velocityX;
        this.ball.y += this.ball.velocityY;
        this.particleSystem.updateParticles();
      }
      if (this.state.gameOver) {
        if (this.state.keyState["Space"]) {
          this.resetGame();
        }
        this.displayGameOverMessage();
        return;
      }
    };
  
    draw = () => {
      this.clearCanvas();
      this.drawPaddle();
      this.drawBall();
      this.drawBlocks();
      this.displayScore();
      this.displayLives();
      this.level.displayLevel();
      this.displayDifficulty();
      this.displayPauseMessage();
      this.displayGameOverMessage();
      this.particleSystem.drawParticles();
    };
  
    startGame = () => {
      this.state.gameStarted = true;
      this.state.gamePaused = false;
      this.animationId = requestAnimationFrame(this.gameLoop);
    };
  
    // Block creation methods
    createBlocks = () => {
      this.blocks = [];
      this.state.blockCount = 0;
      let blockWidth = this.calculateBlockWidth();
      let maxBlockHeight = Math.max(((this.board.height * 2) / 3 - AGAME_BLOCK_Y_OFFSET) / this.blockRows - 10, AGAME_MIN_BLOCK_HEIGHT);
  
      // Create the blocks with the maximum block height
      for (let row = 0; row < Math.min(this.blockRows, AGAME_BOARD_MAX_ROWS); row++) {
        for (let column = 0; column < this.blockColumns; column++) {
          let combinedWords = this.attackMatrix[row][column];
          if (combinedWords) {
            let wordsArray = this.splitWordsToFitBlock(combinedWords, blockWidth);
            let fontSize = this.calculateFontSize(blockWidth, wordsArray.length);
            if (fontSize > maxBlockHeight) {
              fontSize = maxBlockHeight;
            }
            this.board.context.font = fontSize + "px sans-serif";
            let newBlock = this.createBlockObject(column, row, blockWidth, maxBlockHeight, wordsArray, fontSize);
            this.blocks.push(newBlock);
            this.state.blockCount++;
          }
        }
      }
    };
  
    calculateFontSize = (blockWidth, blockHeight) => {
      const area = blockWidth * blockHeight;
      const averageTextLength = 50;
      const fontSize = Math.sqrt(area / averageTextLength);
      return Math.max(10, Math.min(fontSize, 20));
    };
  
    calculateBlockWidth = () => {
      return (this.board.width - 2 * AGAME_BLOCK_X_OFFSET) / this.blockColumns;
    };
  
    splitWordsToFitBlock = (combinedWords, blockWidth) => {
      let wordsArray = [];
      let currentText = "";
      let fontSize = this.calculateFontSize(blockWidth, combinedWords.split(" ").length);
      this.board.context.font = fontSize + "px sans-serif";
      for (let word of combinedWords.split(" ")) {
        let testText = currentText === "" ? word : currentText + " " + word;
        let textWidth = this.board.context.measureText(testText).width;
        if (textWidth > blockWidth - 10) {
          wordsArray.push(currentText);
          currentText = word;
        } else {
          currentText = testText;
        }
      }
      wordsArray.push(currentText);
      return wordsArray;
    };
  
    createBlockObject = (column, row, blockWidth, blockHeight, wordsArray, fontSize) => {
      let newBlock = new Block(
        blockWidth,
        blockHeight,
        AGAME_BLOCK_X_OFFSET + column * blockWidth,
        AGAME_BLOCK_Y_OFFSET + row * blockHeight,
        wordsArray,
        fontSize
      );
      newBlock.textX = newBlock.x + 5; // Add some padding from the left
      newBlock.textY = newBlock.y + 20; // Add some padding from the top
      return newBlock;
    };
  
    // Drawing methods
    clearCanvas = () => {
      this.board.context.clearRect(0, 0, this.board.width, this.board.height);
    };
  
    drawPaddle = () => {
      // Set the fill style to a solid color
      this.board.context.fillStyle = "darkgray";
  
      // Draw the main rectangle for the paddle
      this.board.context.fillRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height);
  
      // Draw horizontal lines across the paddle
      this.board.context.strokeStyle = "black";
      this.board.context.lineWidth = 1;
      for (let y = this.paddle.y; y < this.paddle.y + this.paddle.height; y += 5) {
        this.board.context.beginPath();
        this.board.context.moveTo(this.paddle.x, y);
        this.board.context.lineTo(this.paddle.x + this.paddle.width, y);
        this.board.context.stroke();
      }
  
      // Draw vertical lines at the edges of the paddle
      this.board.context.strokeStyle = "gray";
      this.board.context.lineWidth = 6;
      this.board.context.beginPath();
      this.board.context.moveTo(this.paddle.x, this.paddle.y);
      this.board.context.lineTo(this.paddle.x, this.paddle.y + this.paddle.height);
      this.board.context.stroke();
  
      this.board.context.beginPath();
      this.board.context.moveTo(this.paddle.x + this.paddle.width, this.paddle.y);
      this.board.context.lineTo(this.paddle.x + this.paddle.width, this.paddle.y + this.paddle.height);
      this.board.context.stroke();
    };
  
    drawBall = () => {
      this.board.context.fillStyle = game.theme.currentPreset.ballColor;
      this.board.context.beginPath();
      this.board.context.arc(this.ball.x + this.ball.width / 2, this.ball.y + this.ball.height / 2, this.ball.width / 2, 0, Math.PI * 2);
      this.board.context.fill();
    };
  
    drawBlocks = () => {
      for (let block of this.blocks) {
        if (!block.break) {
          this.board.context.fillStyle = game.theme.currentPreset.blockColor;
          this.board.context.fillRect(block.x, block.y, block.width, block.height);
          this.board.context.strokeStyle = "black";
          this.board.context.lineWidth = 3;
          this.board.context.strokeRect(block.x, block.y, block.width, block.height);
          this.drawBlockText(block);
        }
      }
    };
  
    drawBlockText = (block) => {
      this.board.context.fillStyle = game.theme.currentPreset.blockTextColor;
      this.board.context.font = block.fontSize + "px sans-serif";
      let textY = block.textY;
      for (let word of block.wordsArray) {
        this.board.context.fillText(word, block.textX, textY);
        textY += block.fontSize + 5;
      }
    };
  
    displayDifficulty = () => {
      this.board.context.fillStyle = this.state.gamePaused
        ? game.theme.currentPreset.pauseMessageBoxColor
        : game.theme.currentPreset.textColor;
      this.board.context.font = "20px sans-serif";
      this.board.context.fillText("Difficulty: " + this.state.difficulty, this.board.width - 450, 25);
    };
  
    displayLives = () => {
      this.board.context.fillStyle = this.state.gamePaused
        ? game.theme.currentPreset.pauseMessageBoxColor
        : game.theme.currentPreset.textColor;
      this.board.context.font = "20px sans-serif";
      this.board.context.fillText("Lives: " + this.state.lives, this.board.width - 100, 25);
    };
  
    displayScore = () => {
      this.board.context.fillStyle = this.state.gamePaused
        ? game.theme.currentPreset.pauseMessageBoxColor
        : game.theme.currentPreset.textColor;
      this.board.context.font = "20px sans-serif";
      this.board.context.fillText(this.state.score, 10, 25);
    };
  
    displayStartScreen = () => {
      this.board.context.fillStyle = "red";
      this.board.context.font = "100px sans-serif";
      this.board.context.textAlign = "center";
      this.board.context.fillText("&", this.board.width / 2, this.board.height / 2);
      this.board.context.font = "50px sans-serif";
      this.board.context.fillText("v15", this.board.width / 2, this.board.height / 2 + 60);
      this.board.context.fillText("Press Space for a Sneak Preview", this.board.width / 2, this.board.height / 2 + 120);
      this.board.context.textAlign = "start";
      this.displayGameHistory();
      this.drawDifficultyButtons();
    };
  
    displayGameHistory = () => {
      if (this.state.gameHistory.length > 0) {
        let topScores = this.state.gameHistory.sort((a, b) => b - a).slice(0, 5);
        this.board.context.fillStyle = "white";
        this.board.context.font = "20px sans-serif";
        this.board.context.fillText("Top 5 Scores:", this.board.width / 2, this.board.height / 2 + 180);
        topScores.forEach((score, index) => {
          this.board.context.fillText(`${index + 1}. ${score}`, this.board.width / 2, this.board.height / 2 + 210 + index * 30);
        });
      }
    };
  
    displayMessage = (condition, mainText, subText) => {
      if (condition) {
        this.board.context.fillStyle = game.theme.currentPreset.pauseMessageBoxColor;
        this.board.context.globalAlpha = 0.5;
        this.board.context.fillRect(this.board.width / 2 - 250, this.board.height / 2 - 50, 500, 150);
        this.board.context.globalAlpha = 1;
        this.board.context.fillStyle = game.theme.currentPreset.pauseMessageTextColor;
        this.board.context.font = "40px sans-serif";
        this.board.context.textAlign = "center";
        this.board.context.fillText(mainText, this.board.width / 2, this.board.height / 2 + 10);
        this.board.context.fillText(subText, this.board.width / 2, this.board.height / 2 + 60);
        this.board.context.textAlign = "start";
      }
    };
  
    displayGameOverMessage = () => {
      this.displayMessage(this.state.gameOver, "GAME OVER", "Press Space to Try Again");
    };
  
    displayPauseMessage = () => {
      let mainText = "PAUSED";
      if (this.state.lives < 3 && this.state.gamePaused) {
        mainText = `Lives Remaining: ${this.state.lives}`;
      }
      let subText1 = "Press Space to Continue";
      this.displayMessage(this.state.gamePaused, mainText, subText1);
    };
  
    handleResize = () => {
      this.board.resizeBoard();
      this.paddle.generatePaddleData(this.board.width, this.board.height);
      this.ball.generateInitialBall(this.board.width, this.board.height);
      this.setupGame();
      this.draw();
    };
  
    // Collision detection methods
    checkCollision = (object1, object2) => {
      return object1.left < object2.right && object1.right > object2.left && object1.top < object2.bottom && object1.bottom > object2.top;
    };
  
    handleBallCollision = () => {
      if (this.checkCollision(this.ball, this.paddle)) {
        // Check if ball hit the paddle
        if (this.ball.y < this.paddle.y) {
          this.ball.velocityY = Math.abs(this.ball.velocityY) * -1;
          // Calculate the four zones of the paddle
          let paddleZone1 = this.paddle.x + this.paddle.width * 0.1;
          let paddleZone2 = this.paddle.x + this.paddle.width * 0.5;
          let paddleZone3 = this.paddle.x + this.paddle.width * 0.9;
          // Check which zone the ball hit and adjust the X velocity accordingly
          if (this.ball.x < paddleZone1) {
            this.ball.velocityX = Math.max(this.ball.velocityX - 2, this.state.minBallVelocityX);
          } else if (this.ball.x < paddleZone2) {
            this.ball.velocityX = Math.max(this.ball.velocityX - 1, this.state.minBallVelocityX);
          } else if (this.ball.x < paddleZone3) {
            this.ball.velocityX = Math.min(this.ball.velocityX + 1, this.state.maxBallVelocityX);
          } else {
            this.ball.velocityX = Math.min(this.ball.velocityX + 2, this.state.maxBallVelocityX);
          }
        }
      }
  
      for (let i = 0; i < this.blocks.length; i++) {
        let block = this.blocks[i];
        if (!block.break && this.checkCollision(this.ball, block)) {
          this.blockCollision(block);
        }
      }
    };
  
    blockCollision = (block) => {
      this.particleSystem.createExplosion(block.x + block.width / 2, block.y + block.height / 2, 50);
      block.break = true;
      let scoreIncrement = AGAME_SCORE_INCREMENT;
      if (this.state.difficulty === "Medium") {
        scoreIncrement *= 2;
      } else if (this.state.difficulty === "Hard") {
        scoreIncrement *= 3;
      }
      this.state.score += scoreIncrement;
      this.state.blockCount -= 1;
      // Calculate the differences between the ball and block positions
      let diffTop = Math.abs(this.ball.bottom - block.top);
      let diffBottom = Math.abs(this.ball.top - block.bottom);
      let diffLeft = Math.abs(this.ball.right - block.left);
      let diffRight = Math.abs(this.ball.left - block.right);
      // Find the smallest difference
      let minDiff = Math.min(diffTop, diffBottom, diffLeft, diffRight);
      // Reverse the appropriate velocity based on the smallest difference
      switch (minDiff) {
        // Ball hits top of block, goes up
        case diffTop:
          this.ball.velocityY = Math.abs(this.ball.velocityY) * -1;
          break;
  
        // Ball hits bottom of block, goes down
        case diffBottom:
          this.ball.velocityY = Math.abs(this.ball.velocityY);
          break;
  
        // Ball hits left of block, goes left
        case diffLeft:
          this.ball.velocityX = Math.abs(this.ball.velocityX) * -1;
          break;
  
        // Ball hits right of block, goes right
        case diffRight:
          this.ball.velocityX = Math.abs(this.ball.velocityX);
          break;
      }
    };
  
    checkBallBounds = () => {
      if (this.ball.y <= 0) {
        this.ball.velocityY *= -1;
      } else if (this.ball.x <= 0 || this.ball.x + this.ball.width >= this.board.width) {
        this.ball.velocityX *= -1;
      } else if (this.ball.y + this.ball.height >= this.board.height) {
        this.state.lives -= 1;
        if (this.state.lives === 0) {
          this.state.gameOver = true;
          this.state.gameHistory.push(this.state.score);
        } else {
          this.ball.generateInitialBall(this.board.width, this.board.height);
          this.state.gamePaused = true;
        }
      }
    };
  
    // Game state methods
    checkNextLevel = () => {
      if (this.state.blockCount == 0) {
        this.level.nextLevel();
      }
    };
  
    outOfBounds = (xPosition) => {
      return xPosition < 0 || xPosition > this.board.width - this.paddle.width;
    };
  
    handleArrowLeftKey = () => {
      if (!this.state.gamePaused) {
        const nextPaddleX = this.paddle.x - this.paddle.velocityX;
        if (!this.outOfBounds(nextPaddleX)) {
          this.paddle.x = nextPaddleX;
        } else {
          this.paddle.x = 0;
        }
      }
    };
  
    handleArrowRightKey = () => {
      if (!this.state.gamePaused) {
        const nextPaddleX = this.paddle.x + this.paddle.velocityX;
        if (!this.outOfBounds(nextPaddleX)) {
          this.paddle.x = nextPaddleX;
        } else {
          this.paddle.x = this.board.width - this.paddle.width;
        }
      }
    };
  
    handleSpaceKey = () => {
      if (!this.state.gameStarted) {
        pass;
      } else if (this.state.gameOver) {
        this.resetGame();
      } else if (!this.state.gamePaused) {
        this.state.gamePaused = true;
        cancelAnimationFrame(this.animationId);
        this.displayPauseMessage();
      } else {
        this.state.gamePaused = false;
        cancelAnimationFrame(this.animationId);
        this.animationId = requestAnimationFrame(this.gameLoop);
      }
    };
  
    resetGame = () => {
      this.state.initialState();
      this.setupCanvas();
      this.setupGame();
    };
  }
  
  let game = new Game();
  
  window.onload = function () {
    game.setup();
  };
</script>

<script type="application/javascript">
    const reconnaissanceTechniques = [
    "Active Scanning",
    "Gather Victim Host Information",
    "Gather Victim Identity Information",
    "Gather Victim Network Information",
    "Gather Victim Org Information",
    "Phishing for Information",
    "Search Closed Sources",
    "Search Open Technical Databases",
    "Search Open Websites/Domains",
    "Search Victim-Owned Websites",
  ];
  
  const resourceDevelopmentTechniques = [
    "Acquire Infrastructure",
    "Compromise Accounts",
    "Compromise Infrastructure",
    "Develop Capabilities",
    "Establish Accounts",
    "Obtain Capabilities",
    "Stage Capabilities",
  ];
  
  const initialAccessTechniques = [
    "Content Injection",
    "Drive-by Compromise",
    "Exploit Public-Facing Application",
    "External Remote Services",
    "Hardware Additions",
    "Phishing",
    "Replication Through Removable Media",
    "Supply Chain Compromise",
    "Trusted Relationship",
    "Valid Accounts",
  ];
  
  const executionTechniques = [
    "Cloud Administration Command",
    "Command and Scripting Interpreter",
    "Container Administration Command",
    "Deploy Container",
    "Exploitation for Client Execution",
    "Inter-Process Communication",
    "Native API",
    "Scheduled Task/Job",
    "Serverless Execution",
    "Shared Modules",
    "Software Deployment Tools",
    "System Services",
    "User Execution",
    "Windows Management Instrumentation",
  ];
  
  const persistenceTechniques = [
    "Account Manipulation",
    "BITS Jobs",
    "Boot or Logon Autostart Execution",
    "Boot or Logon Initialization Scripts",
    "Browser Extensions",
    "Compromise Client Software Binary",
    "Create Account",
    "Create or Modify System Process",
    "Event Triggered Execution",
    "External Remote Services",
    "Hijack Execution Flow",
    "Implant Internal Image",
    "Modify Authentication Process",
    "Office Application Startup",
    "Power Settings",
    "Pre-OS Boot",
    "Scheduled Task/Job",
    "Server Software Component",
    "Traffic Signaling",
    "Valid Accounts",
  ];
  
  const privilegeEscalationTechniques = [
    "Abuse Elevation Control Mechanism",
    "Access Token Manipulation",
    "Account Manipulation",
    "Boot or Logon Autostart Execution",
    "Boot or Logon Initialization Scripts",
    "Create or Modify System Process",
    "Domain Policy Modification",
    "Escape to Host",
    "Event Triggered Execution",
    "Exploitation for Privilege Escalation",
    "Hijack Execution Flow",
    "Process Injection",
    "Scheduled Task/Job",
    "Valid Accounts",
  ];
  
  const defenseEvasionTechniques = [
    "Abuse Elevation Control Mechanism",
    "Access Token Manipulation",
    "BITS Jobs",
    "Build Image on Host",
    "Debugger Evasion",
    "Deobfuscate/Decode Files or Information",
    "Deploy Container",
    "Direct Volume Access",
    "Domain Policy Modification",
    "Execution Guardrails",
    "Exploitation for Defense Evasion",
    "File and Directory Permissions Modification",
    "Hide Artifacts",
    "Hijack Execution Flow",
    "Impair Defenses",
    "Impersonation",
    "Indicator Removal",
    "Indirect Command Execution",
    "Masquerading",
    "Modify Authentication Process",
    "Modify Cloud Compute Infrastructure",
    "Modify Registry",
    "Modify System Image",
    "Network Boundary Bridging",
    "Obfuscated Files or Information",
    "Plist File Modification",
    "Pre-OS Boot",
    "Process Injection",
    "Reflective Code Loading",
    "Rogue Domain Controller",
    "Rootkit",
    "Subvert Trust Controls",
    "System Binary Proxy Execution",
    "System Script Proxy Execution",
    "Template Injection",
    "Traffic Signaling",
    "Trusted Developer Utilities Proxy Execution",
    "Unused/Unsupported Cloud Regions",
    "Use Alternate Authentication Material",
    "Valid Accounts",
    "Virtualization/Sandbox Evasion",
    "Weaken Encryption",
    "XSL Script Processing",
  ];
  
  const credentialAccessTechniques = [
    "Adversary-in-the-Middle",
    "Brute Force",
    "Credentials from Password Stores",
    "Exploitation for Credential Access",
    "Forced Authentication",
    "Forge Web Credentials",
    "Input Capture",
    "Modify Authentication Process",
    "Multi-Factor Authentication Interception",
    "Multi-Factor Authentication Request Generation",
    "Network Sniffing",
    "OS Credential Dumping",
    "Steal Application Access Token",
    "Steal or Forge Authentication Certificates",
    "Steal or Forge Kerberos Tickets",
    "Steal Web Session Cookie",
    "Unsecured Credentials",
  ];
  
  const discoveryTechniques = [
    "Account Discovery",
    "Application Window Discovery",
    "Browser Information Discovery",
    "Cloud Infrastructure Discovery",
    "Cloud Service Dashboard",
    "Cloud Service Discovery",
    "Cloud Storage Object Discovery",
    "Container and Resource Discovery",
    "Debugger Evasion",
    "Device Driver Discovery",
    "Domain Trust Discovery",
    "File and Directory Discovery",
    "Group Policy Discovery",
    "Log Enumeration",
    "Network Service Discovery",
    "Network Share Discovery",
    "Network Sniffing",
    "Password Policy Discovery",
    "Peripheral Device Discovery",
    "Permission Groups Discovery",
    "Process Discovery",
    "Query Registry",
    "Remote System Discovery",
    "Software Discovery",
    "System Information Discovery",
    "System Location Discovery",
    "System Network Configuration Discovery",
    "System Network Connections Discovery",
    "System Owner/User Discovery",
    "System Service Discovery",
    "System Time Discovery",
    "Virtualization/Sandbox Evasion",
  ];
  
  const lateralMovementTechniques = [
    "Exploitation of Remote Services",
    "Internal Spearphishing",
    "Lateral Tool Transfer",
    "Remote Service Session Hijacking",
    "Remote Services",
    "Replication Through Removable Media",
    "Software Deployment Tools",
    "Taint Shared Content",
    "Use Alternate Authentication Material",
  ];
  
  const collectionTechniques = [
    "Adversary-in-the-Middle",
    "Archive Collected Data",
    "Audio Capture",
    "Automated Collection",
    "Browser Session Hijacking",
    "Clipboard Data",
    "Data from Cloud Storage",
    "Data from Configuration Repository",
    "Data from Information Repositories",
    "Data from Local System",
    "Data from Network Shared Drive",
    "Data from Removable Media",
    "Data Staged",
    "Email Collection",
    "Input Capture",
    "Screen Capture",
    "Video Capture",
  ];
  
  const commandAndControlTechniques = [
    "Application Layer Protocol",
    "Communication Through Removable Media",
    "Content Injection",
    "Data Encoding",
    "Data Obfuscation",
    "Dynamic Resolution",
    "Encrypted Channel",
    "Fallback Channels",
    "Ingress Tool Transfer",
    "Multi-Stage Channels",
    "Non-Application Layer Protocol",
    "Non-Standard Port",
    "Protocol Tunneling",
    "Proxy",
    "Remote Access Software",
    "Traffic Signaling",
    "Web Service",
  ];
  
  const exfiltrationTechniques = [
    "Automated Exfiltration",
    "Data Transfer Size Limits",
    "Exfiltration Over Alternative Protocol",
    "Exfiltration Over C2 Channel",
    "Exfiltration Over Other Network Medium",
    "Exfiltration Over Physical Medium",
    "Exfiltration Over Web Service",
    "Scheduled Transfer",
    "Transfer Data to Cloud Account",
  ];
  
  const impactTechniques = [
    "Account Access Removal",
    "Data Destruction",
    "Data Encrypted for Impact",
    "Data Manipulation",
    "Defacement",
    "Disk Wipe",
    "Endpoint Denial of Service",
    "Financial Theft",
    "Firmware Corruption",
    "Inhibit System Recovery",
    "Network Denial of Service",
    "Resource Hijacking",
    "Service Stop",
    "System Shutdown/Reboot",
  ];
  
  function createAttackMatrix() {
    const attackMatrix = [];
  
    const tactics = [
      "Reconnaissance",
      "Resource Development",
      "Initial Access",
      "Execution",
      "Persistence",
      "Privilege Escalation",
      "Defense Evasion",
      "Credential Access",
      "Discovery",
      "Lateral Movement",
      "Collection",
      "Command and Control",
      "Exfiltration",
      "Impact",
    ];
  
    const techniqueLists = [
      reconnaissanceTechniques,
      resourceDevelopmentTechniques,
      initialAccessTechniques,
      executionTechniques,
      persistenceTechniques,
      privilegeEscalationTechniques,
      defenseEvasionTechniques,
      credentialAccessTechniques,
      discoveryTechniques,
      lateralMovementTechniques,
      collectionTechniques,
      commandAndControlTechniques,
      exfiltrationTechniques,
      impactTechniques,
    ];
  
    // Add tactic names as the first row
    attackMatrix.push(tactics);
  
    // Iterate over technique lists and construct the matrix
    let maxTechniques = 0;
    for (const techniques of techniqueLists) {
      if (techniques.length > maxTechniques) {
        maxTechniques = techniques.length;
      }
    }
  
    for (let i = 0; i < maxTechniques; i++) {
      const row = [];
      for (const techniques of techniqueLists) {
        row.push(i < techniques.length ? techniques[i] : null);
      }
      attackMatrix.push(row);
    }
  
    return attackMatrix;
  }
</script>